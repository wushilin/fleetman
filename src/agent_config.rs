use serde::Deserialize;

#[derive(Debug, Deserialize, Clone)]
pub struct AgentConfig {
    pub global: GlobalConfig,
    pub object_storage: ObjectStorageConfig,
    pub systemd: Option<SystemdConfig>,
    pub deploy: Option<DeployConfig>,
    pub processmaster: Option<ProcessMasterConfig>,
}

#[derive(Debug, Deserialize, Clone)]
pub struct DeployConfig {
    pub target_folder: String,  // e.g., /opt/deployed
}

#[derive(Debug, Deserialize, Clone)]
pub struct GlobalConfig {
    pub node_id: String,
    pub check_interval_ms: u64,
    pub log_directory: Option<String>,
    pub log_file_prefix: Option<String>,
    #[serde(default = "default_log_rotation")]
    pub log_rotation: String, // "daily", "hourly", "never"
    #[serde(default = "default_s3_retry_count")]
    pub s3_retry_count: u32,
    #[serde(default = "default_s3_retry_delay_ms")]
    pub s3_retry_delay_ms: u64,
    /// Whether to automatically rollback to the previous version on deployment failure.
    /// Defaults to true.
    #[serde(default = "default_rollback_on_failure")]
    pub rollback_on_failure: bool,
}

fn default_log_rotation() -> String {
    "daily".to_string()
}

fn default_s3_retry_count() -> u32 {
    3
}

fn default_s3_retry_delay_ms() -> u64 {
    1000
}

fn default_rollback_on_failure() -> bool {
    true
}

#[derive(Debug, Deserialize, Clone)]
pub struct ObjectStorageConfig {
    pub endpoint: String,
    pub access_key: String,
    pub secret_key: String,
    pub bucket: String,
    pub path_style: Option<bool>,
    pub prefix: String,  // Required: must contain only alphanumerics, hyphens, and underscores
}

impl ObjectStorageConfig {
    pub fn full_key(&self, key: &str) -> String {
        format!("{}/{}", self.prefix, key)
    }
}

#[derive(Debug, Deserialize, Clone)]
pub struct SystemdConfig {
    pub service_folder: String,        // e.g., /etc/systemd/system
    pub working_directory: String,     // e.g., /opt/services
    /// Deprecated (no longer used): systemd unit files come from the deployment's `app.service`
    /// generated by Fleetman and rendered by FleetAgent.
    #[allow(dead_code)]
    pub template_path: Option<String>,
    pub systemctl_path: Option<String>, // Default: /usr/bin/systemctl
}

#[derive(Debug, Deserialize, Clone)]
pub struct ProcessMasterConfig {
    /// Path to pmctl binary (e.g. /usr/bin/pmctl).
    pub pmctl_path: String,
    /// Optional unix socket path. If not set, pmctl will use PMCTL_SOCK env var or its default.
    pub sock: Option<String>,
    /// The auto services root folder where Fleetman will write service definitions (service.yml + run.sh).
    pub auto_services_root: String,
}

impl SystemdConfig {
    pub fn systemctl_path(&self) -> String {
        self.systemctl_path
            .clone()
            .unwrap_or_else(|| "/usr/bin/systemctl".to_string())
    }
}


